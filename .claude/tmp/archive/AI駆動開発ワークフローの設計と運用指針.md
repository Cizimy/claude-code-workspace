# AI駆動開発ワークフローの設計と運用指針

## 背景と目標

個人開発のWebアプリ/APIバックエンドプロジェクトにおいて、将来的にAnthropic Claudeのエージェント（Claude Code）を主導とした**AI駆動型の開発フロー**を構築します。重要な目標は、**テスト駆動開発（TDD）**と**YAGNI（You Aren’t Gonna Need It）原則**を堅持し、AIがコードを提案・実装・修正する際に不要な複雑性の増大を抑制することです。具体的には、GitHub上でIssue駆動の開発を行い、ClaudeエージェントがPull Request (PR)を自動生成・更新します。その際、プロジェクトの「憲法」とも言えるガイドラインを**CLAUDE.md**に定義し、Claudeの出力をレビュー・監査する\*\*Hooks（フック）\*\*で自動チェックと制御を行います。これにより、人間の開発者と協調しつつも、AIエージェントが暴走せず品質の高いコードを継続的に生み出すワークフローを目指します。

以下、この開発フローの全体設計と各要素の運用指針について詳述します。

## Claude Codeのフレームワーク: コンテクスト→ツール→権限制御→実行→フィードバック

Claude Codeエージェントは、\*\*「コンテクスト→ツール→権限制御→実行→フィードバック」\*\*のサイクルで動作します。この枠組みを理解し整備することが、TDDやYAGNI原則を守りつつAI開発を制御する基本となります。

* **コンテクスト（Context）**: Claudeはまず与えられたコンテクストをもとに思考します。ここにはGitHub Issueの内容（要求仕様やバグ報告など）、関連する既存コードやドキュメント、およびプロジェクトのガイドライン（CLAUDE.md）が含まれます。CLAUDE.mdに記載したコード規約や設計原則は**不変のシステムルール**として扱われ、ユーザープロンプトよりも強い影響力を持ちます。このため、プロジェクト独自のTDD推進方針やYAGNIルールもCLAUDE.mdで定義しておけば、Claudeはそれを絶対的な前提として開発を進めます。

* **ツール（Tools）**: Claude Codeは対話型のエージェントであり、必要に応じて様々な「ツール」を実行できます。例えばファイルの読み書き、コードの編集、テストコマンドの実行、ウェブ検索、Git操作（GitHub CLI経由）などがツールとして定義されています。Claudeは課題を解決するためにこれらのツールを順次呼び出し、コードベースを変更したり外部情報を取得したりします。本フローでは特に**テストの実行ツール**（例: `npm test` や `pytest` 等）と**Git操作ツール**（例: `gh` CLIを使ったPR作成）を積極的に活用します。Claudeがツールを使う際には、一連の手順（テストを実行→失敗を確認→コードを編集→再テスト…）が人手を介さず自動で進むよう、許可設定を調整します。

* **権限制御（Permission Control）**: Claude Codeはデフォルトで危険な操作やシステム変更を行う際に確認を求める保守的な挙動を持ちます。この開発フローでは、反復的な開発サイクルを止めないよう、**許可の自動化**と**Hooksによるルール監視**を組み合わせます。`/.claude/settings.json`の**allowedTools**リストで安全な操作（例えばファイル編集やテスト実行、`git commit`等）はあらかじめ常時許可し、手動確認を省きます。一方で、**フック**を使った権限制御により、Claudeの各ツール実行をリアルタイムで監査します。Claude Code HooksはClaudeのライフサイクル上の特定イベントで自動実行されるシェルスクリプトで、LLMの判断とは独立した**決定論的な統制**手段です。例えばPreToolUseフックを設定すれば、Claudeがあるツールを呼ぶ直前にフックが介入し、そのコマンド内容を検査して不適切ならブロックできます。Hooksは**exitコード**や構造化JSONを通じてClaudeへフィードバックを返し、exitコード2を返すと該当ツールの実行自体をキャンセルしてClaudeにエラーメッセージを与えられます。この仕組みを利用し、本フローでは**プロジェクトのルールに反する操作や出力をフックで事前に検知・遮断**します。例えば「要求にない新機能を実装しようとしている」「テストを書かずにコードを書こうとしている」といった兆候があれば、フックが検知してClaudeにエラーを返し、修正（テスト追加や不要コード削除）を促します。

* **実行（Execution）**: 許可されたツールは実際にシェル上で実行され、コードの変更やテストの実施といった**具体的なアクション**が行われます。Claudeはファイルを書き換えたり、新規ファイル（テストコード等）を作成したり、`npm run test`や`pytest`等のコマンドを叩いてテストスイートを走らせたりします。その結果、ファイル差分やテスト結果ログなどが生成されます。Claude Codeでは**PostToolUseフック**で各ツール完了後に追加処理を差し込むことも可能です。例えば「ファイルを書き換えた後、自動でコード整形ツールを実行する」「テストコマンド完了後にカバレッジを収集・検査する」といった処理を自動化できます。実行フェーズでは、Claudeが**できるだけ小さな粒度でコミット**し、変更を蓄積しすぎないこともポイントです。後述するように、テストコードの追加とそれに対応する実装は別々のコミット/PRにするか、最低でもコミット内で明確に分けて行うことで、変更の粒度を細かく保ちます（これによりレビューしやすくロールバックもしやすい）。

* **フィードバック（Feedback）**: Claudeはツールの実行結果を逐次読み取り、次の行動に反映させます。具体的には、**テストの成功/失敗結果**や**Lintツールの指摘、型チェックのエラー**などがフィードバック情報となります。TDDワークフローではフィードバックとしてまず「追加したテストが失敗すること」を確認し、その後「テストがパスするまで実装を繰り返す」ことになります。さらに本フローでは、**Hooksによるフィードバック**も活用します。PreToolUseフックが何らかのブロックを行った場合、Claudeにはstderr経由でエラーメッセージが伝えられます。Claudeはこのメッセージを解析し、方針を修正して再試行します（例えば「未使用の関数が検出されたので削除します」といった自己修正を行う）。またStopフックを使えば、Claudeが「完了」と判断して応答を終了しようとした際にも介入が可能です。Stopフックでexitコード2を返すとClaudeは**応答終了をブロックされ、タスク継続を強制**されます。これにより、例えば\*\*「テストがまだ赤いのに終了しようとした」\*\*場合にStopフックで完了を差し止め、Claudeに「テストが全て通るまで続行せよ」というフィードバックを与えることができます。以上のようなフィードバックループを回し続けることで、Claudeが逐次的にコードを修正・改良し、最終的にプロジェクト基準を満たす解を得るまで動き続ける仕組みを構築します。

以上のコンテクスト→ツール→権限制御→実行→フィードバックのサイクルを整えることで、AIエージェントの行動をきめ細かく管理し、人間の意思やプロジェクト方針に沿った開発を実現できます。次節から、このサイクルを具体的に活用したGitHub上のワークフロー設計を説明します。

## GitHub Actionsを用いたClaudeエージェントの開発フロー

今回の想定では、GitHub上でIssueとPull Requestを軸に開発を進めます。**Claude Code GitHub Actions**を導入することで、GitHub上で`@claude`とメンションするだけでClaudeエージェントがコード解析・PR作成・バグ修正などを自動で行ってくれます。以下は本フローの全体像です。

1. **Issue駆動のタスク管理**: 開発タスクはGitHub Issueで管理します。新機能の追加やバグ修正など、全てをIssueに起こし、受け入れ基準や再現手順、仕様要件を明記します。特にTDDを行うため、Issueには**期待する挙動とそれを検証するテストケース**を箇条書きするなど、テスト観点での記述を含めると効果的です（テンプレート活用）。将来的に複数のClaudeエージェントが並行してIssueを処理することも想定し、各Issueはできるだけ**独立かつ小規模**に切り分けます。一つのIssueで複数の大きな変更を求めないことで、AIによる対応も局所化し、結果としてPR粒度も細かくなります。

2. **ClaudeによるIssue解析とプランニング**: Issueが準備できたら、コメントで`@claude`をメンションし「このIssueの内容を実装してください」と指示します。GitHub Actionsがトリガーされ、Claude Codeエージェントが起動します。ClaudeはまずIssueの本文とCLAUDE.mdを読み込み、問題を理解します。必要に応じて関連ファイル（既存のコード）もClaudeに読ませます。ポイントは**いきなりコードを書かせず、まず計画を立てさせる**ことです。Claudeに「考えて（think）プランを示してください」と促すと、Claudeは追加の思考時間を使って解決方針やステップを提示します。この際、人間開発者（または監視用の別エージェント）はClaudeのプランを確認し、**過剰な実装や不必要な複雑化がないか**チェックします（Claudeの提案がYAGNI違反を含んでいないか、分離すべき関心ごとを一つにまとめていないかなど）。もし問題があれば、この段階でフィードバックを返すか、必要ならHooksのStop機能でClaudeに計画修正を促します。適切なプランが整ったら、Claudeにその通り実行するよう合図します。

3. **テスト駆動開発サイクルの自動実行**: ClaudeはIssueに基づいて**TDDのサイクル**を実行します。まず、「テストを書いてください」との指示（またはCLAUDE.md上のルール）に従い、期待される機能やバグ再現に対応する**テストコードを生成**します。このときClaudeに対し「これからTDDを行う」と明示することで、存在しない機能に対する仮実装や不要なモックを勝手に書かないよう注意させます。Claudeは新規テストファイルやテスト関数を作成し、プロジェクトに合わせた単体テスト/統合テストを書きます。続いてClaudeは**テストスイートを実行**し、追加したテストが失敗することを確認します。この「まずテストが落ちることを確認する」ステップは非常に重要で、Issueで意図した不具合再現や機能不足が正しくテストで捉えられているかを証明します（いわば守るべきレッドグリーンサイクルの“レッド”を確認する段階です）。Claudeには「実装コードはまだ書かないで」と明示してテスト実行のみ行わせることで、コードを書き始める前にこの失敗をちゃんと認識させます。

   テストが失敗したら、Claudeはいよいよ**実装コードの作成**に入ります。ここでも一度に大規模実装するのではなく、**最小限の変更でテストをパスさせる**よう誘導します。Claude.mdに定義したYAGNI原則に則り、「現在必要とされていることだけ」を実装対象とします。Claudeはファイル編集ツールを用いて対象ソースコードに必要な変更を加え、新しい関数やロジックを実装します。その際、CLAUDE.mdに記載した**コーディング規約や設計パターン**も参照して、既存のコードベースに沿った実装を行います（例えば「同様の機能は他のモジュールでどう書かれているか」を類推します）。コードを書き終えたらClaudeは再度**テストを実行**し、テストが全てパスするか確認します。多くの場合、一度で緑（成功）にはならないため、Claudeは失敗したテストのフィードバックを元にコードを修正するループを回します。Claude Codeはこのような反復改善が得意であり、テストという明確なターゲットがあることで収束しやすくなります。開発者はこの自動サイクルを見守り、必要に応じて途中で「余計な実装をしすぎていないか」「テストを改変していないか」確認します。Claude.mdに「テストコードを改変してはならない」旨も記載しておくことで、Claudeが失敗するテストを都合よく書き換えてしまうのを防ぎます（過去の試行で得た教訓をルール化）。Claudeは**すべてのテストが緑になるまでコード修正→テスト実行を繰り返し**、最終的にグリーンとなった時点で実装完了となります。

4. **Pull Requestの生成とマージ**: テストが全て通ったら、Claudeは変更をGitに**コミット**し、**Pull Requestを自動作成**します。コミットメッセージやPRタイトル/説明文もClaudeが生成しますが、CLAUDE.mdに「コミットメッセージの書き方」や「PRの説明テンプレート」を記載しておくことで、これもプロジェクト標準に沿ったものになります（例えば「Fix #ISSUE: 概要…」という形式など）。Claude Codeはdiffや履歴を見て賢くメッセージを作ることができるため、適切に設定すればかなり読みやすいPRを出力します。PR作成後、自動で**CIパイプライン**（GitHub Actions上のテスト・Lint実行など）が走り、外部から見ても品質が担保されていることを確認します。Claudeが事前にローカルでテストを通しているのでCIもパスするはずですが、もしCIで問題が見つかった場合（例: 他部分との統合での不具合、カバレッジ低下など）、その結果をもとに再度ClaudeにIssueとしてフィードバックします（またはHooksで検知してClaudeを継続実行させる）。最終的に人間の開発者（または別のClaudeインスタンスによる**自動コードレビュー**）がPRの内容をチェックします。Claudeの提案コードに誤りや改善点があればレビューコメントを付け、`@claude`メンションで「レビュー指摘に従って修正してください」と依頼すれば、Claudeが差分修正をコミットしてPRを更新します。このように、人間は主に**要件定義と最終レビュー**に集中し、コーディングとテストサイクルはClaudeに任せるという分業が実現します。

5. **並行開発とコンフリクト防止**: 今回は個人開発で順次タスク処理する前提ですが、将来的に複数Claudeエージェントが並行で異なるIssue対応をする可能性もあります。並行時にはGitHubの**並列実行制御**を用いて、同時に走るClaude Actionの数を制限したり（必要に応じてQueue化）、あるいは別ブランチ間の変更が衝突しないようIssueの担当範囲を明確に区切る運用が必要です。例えば、一方のエージェントがデータベース周りを実装中に、もう一方はフロントエンドのみ触る、といった具合に領域を分けます。それでもPR間でコンフリクトが起きた場合は、人間がマージ順を調整したり、Claudeに「最新のmainブランチをマージしてコンフリクトを解消せよ」と指示して対応させます。Claude CodeはGitリベースやコンフリクト解決も得意なので、ガイドラインに沿って慎重に対処させれば大きな問題無く複数エージェント開発が可能です。ただし複雑性抑制の観点では、**同時並行のタスク数を絞る**方が安全です。特にプロジェクト初期には一つずつ確実にタスクを終わらせ、ルールやフローを洗練させてから並行度を上げることを推奨します。

以上がGitHubとClaude Codeを組み合わせた基本フローです。次章以降では、この中で特に**TDDとYAGNI原則を守るための具体的仕組み**や、**複雑性を抑える自動チェック**の設計について詳しく掘り下げます。

## TDDとYAGNIを徹底するための制御構造

AIエージェントを使った開発では、放っておくとAIが余計な機能実装や過度な一般化をしてしまうケースがあります（要求以上のことまで「気を利かせて」実装しようとしてしまう）。そこで本ワークフローでは、**テスト駆動開発（TDD）**の徹底と**YAGNI原則（必要なもの以外作らない）の順守**を柱に据え、Claudeの動作を制御します。それぞれについて、どのような仕組みで保証するかを説明します。

### テスト駆動開発（TDD）の促進と保証

*TDDをClaudeに遵守させるためのポイントとメカニズム:*

* **明示的なテストファーストの指示**: まず、CLAUDE.mdやIssueテンプレートに\*\*「テストが先」**であることを明文化します。例えば「必ず実装前に失敗するテストケースを書くこと」「テストが落ちたことを確認してから最小限の実装を行うこと」といった手順を記載します。Anthropicもベストプラクティスとして、Claudeに対し**“これからTDDを行う”\*\*と明示するよう推奨しています。こうすることで、Claudeが実装すべき機能がまだ存在しない段階でも不適切なモックコードを書こうとしたり、テストより先に本体コードを書き始めたりするのを防ぎます。

* **テストコードの自動生成とコミット**: ClaudeにはIssueの受け入れ基準からテストコードを起こさせます。理想的には、Claudeが生成したテストを**一旦人間（または別エージェント）がレビュー**し、要件を過不足なく捉えているか確認します。問題なければClaudeにそのテストを**コミット**させます。ここで一度コミットするのは、後からの差分確認や万一の巻き戻しを容易にするためです。コミット権限はClaudeに与えておき（`Bash(git commit:*)`を許可するなど）、PreToolUseフックで`git commit`コマンドを検知してコミット内容をチェックできます。例えばコミットメッセージに`Add tests for ...`というキーワードがあるかを見て、なければ「テストコミットが先に行われていない」と判断してブロックする、といった運用も考えられます。なおGitHub Actions経由の場合、Claudeは直接`git push`するのではなく、アクションがClaudeの生成した差分をPRとして投稿する仕組みかもしれません。その場合でも、Claudeの出力に含まれる**diff**内で「テストコードの追加」が先に来ていること、もしくはテストと実装の追加が同一PR内なら**テストファイルの変更が含まれていること**を検証します。これらを自動でチェックするフックを導入し、テストなしにコードだけ変更しようとした場合は差し戻すようにします。

* **テスト実行の自動化と失敗検知**: Claude Codeにテストコマンド（例: `npm test`や`pytest`）をツールとして実行させ、その結果（成功/失敗）をClaude自身が解析します。Claudeは自律的にテスト結果を読んで次の行動を決めますが、ここにもHookを組み込めます。具体的には、PostToolUseフックでテストコマンドの出力をパースし、**失敗したテストの数や内容を要約してClaudeにフィードバック**できます。Claudeは通常テスト結果ログをそのまま受け取りますが、大量のログより要点だけ伝えた方が効率が良い場合、フックで整形します。また、Stopフックを活用して\*\*「テストが失敗している限り対話を終わらせない」\*\*制御も可能です。「まだテストが赤いため終了不可」といったメッセージをClaudeに与え、強制的に追加の修正提案を出させます。これにより、Claudeが途中で「あきらめて」レスポンスを終えるのを防止し、TDDのRed/Greenが完了するまでループを継続させられます。

* **実装時のTDD違反検出**: Claudeが実装コードを書く際に、TDDに反する行動（例えばテストで要求されていない別機能の実装や、テストを書いていない箇所の修正）をしていないかチェックします。これには**静的解析**や**差分検証**の手法を用います。一つのアプローチは、**新規または変更されたコード行がすべて何らかのテストによってカバレッジされているか検証する**ことです。例えばPostToolUseフックでテスト実行後にカバレッジレポートを解析し、今回追加・変更した行に未カバーがあればエラーを返す、という運用が考えられます。未使用コードの検出については後述するHooksパターンと重なりますが、TDDの観点では「テストに失敗するコードが無い＝余計な実装をしていない」と言えます。逆に言えば、**テストが緑であっても未使用関数や呼ばれていないロジックが残っていたら、それはYAGNI違反の可能性**があります。これもフックで検出し、Claudeに「この関数はテストで使われていませんが本当に必要ですか？」とフィードバックすることで、不要なら削除させる、必要ならその関数をテストするケースを追加させる、という対応を自動化できます。

* **テストコードの品質維持**: TDDではテストコード自体の品質も重要です。Claudeが書いたテストが冗長すぎたり非効率な場合、人間が手直しすることも考えられます。しかしAIエージェント主導で自動化度を高めるなら、Claude自身にテストコードの改善もさせたいところです。CLAUDE.mdに「テストコードにもリファクタリング基準を適用する」「重複を避ける（DRY原則）」等を記載し、場合によっては**テスト用のLint**（例えばpytestのチェックや、カバレッジ閾値の設定）をCIで走らせます。Hookでは、Test実行後のPostToolUseで「テスト実行時間が極端に長い」「テストでスキップやTODOが残っている」等を検出して注意させることも可能です。もっとシンプルには、Claudeに対し\*\*「実装が完了したらテストコードと実装コードを共に振り返って簡潔か確認せよ」\*\*と最終ステップで促すテンプレートを用意するのも手です。

要するに、本フローでは\*\*「テスト無きコード変更を許さない」\*\*ことを徹底します。Claudeには常にテスト駆動の手順を踏ませ、Hooksとガイドラインでそれを強制・補助することで、AIであっても人間同様にTDDサイクルを守らせるわけです。この仕組みにより、無計画なコード追加やテスト漏れが大幅に減り、結果として将来的なデグレや複雑性の爆発を防ぎます。

### YAGNI原則の順守と複雑性の抑制

*YAGNI（今使わない機能は作らない）の原則をClaudeに守らせ、必要最低限の実装に留めるための方策:*

* **YAGNIルールの明文化**: CLAUDE.mdに**YAGNI原則**を明確に記載します。例えば「要求に含まれない機能は決して実装しないこと」「『将来必要になるかも』という理由での汎用化は禁止」などです。実は、Claudeにプロンプトで「KISS, YAGNI, SOLID原則を守って」と伝えるだけでも、コードが過剰に肥大化するのを防げることが報告されています。特にYAGNIを念頭に置かせると、Claudeは**推測に基づく機能追加を避け、目の前の課題に必要な実装だけに集中**するようになります。その結果、コードのサイズはほぼ半分に減り、余計な「もしも」ケースの処理や設定項目が激減したとの指摘もあります。このため、CLAUDE.mdやIssue記述でYAGNI遵守を繰り返し強調します。

* **不要なコードの検出と排除**: Claudeが提案したコードの中で**使われていない部分**を自動検出し、削除を促します。典型的なのは「未使用の関数・メソッド」「どこからも呼ばれていないクラスや変数」です。これらはYAGNI違反の兆候（=将来のために用意したが現状不要）なので、CIやHookで検知します。方法としては、静的解析ツール（例えばPythonなら`vulture`、Javaなら`unused code detector`等）をPostToolUseフックで走らせることが考えられます。Claude Code Hooksの**PostToolUse**フックはツール実行後に動作するため、例えばClaudeがコードを書き終えた直後（またはStopフック直前）に `vulture .` を実行し、その結果リストに新規追加コードが含まれていたらエラーを投げる、といった仕組みを作れます。Claudeはエラーを受け取ると「未使用の関数Xが検出されたので削除します」と自律的に対応するでしょう。このようにして**死んだコードを残さない**よう自動修正させます。YAGNI原則の効果として、**不要な機能を作らないことでコードの保守負荷を低減**できるとされています。フックを通じた未使用コードの駆逐はそれを技術的に支えるものです。

* **過度な一般化や抽象化の防止**: AIは時に「柔軟な再利用性」を求めて設計を複雑にしがちですが、YAGNIの立場からは今使わない汎用性は不要です。CLAUDE.mdに「最低限の抽象化に留めること」「一回しか使わないコードを共通化しない」等のガイドラインを書き、人間のコードレビューでもその点を注視します。Claudeがインターフェースや汎用クラスを提案してきたら、「現状その汎用性は必要か？」と問い直すように促します。テンプレートとして、Claudeに実装前に「その設計はシンプルですか？もっと簡単にできませんか？」と自問させるチェックポイントを組み込むのも有効です。Claude.md内で「KISS（Keep It Simple, Stupid）の原則を遵守すること」と記載しておけば、Claudeは提案コードを出す際に複雑化を避ける傾向が強まります。実際、KISSやYAGNIを指示したところ\*\*「ノイズを切り落とし、必要十分な解を出すようになった」との報告もあります\*\*。

* **ドメイン逸脱の監視**: Claudeが担当Issueの範囲を超えて別領域のコードに手を出さないよう制御します。例えば「UIに関するIssueでバックエンドの設定を変更し始めた」「データ層のIssueで外部API連携まで実装しようとした」等、**Issue記述のドメインから逸脱した動き**は複雑性を招くため禁止します。これには**Issueと変更ファイルの関連性チェック**を行うフックが考えられます。Claudeの出したPRの差分を解析し、Issueタグ（ラベル）と無関係なモジュールへの変更が含まれていないかを確認します。仮に含まれていたら、Stopフックで「変更範囲がIssueのドメインを超えています」とClaudeに伝え、余計な変更部分を取り除くよう促します。Claude Code Hooksはファイルパターンマッチによるフック発火も可能で、例えば特定ディレクトリ（例: `frontend/`ディレクトリ）のファイル編集を検知して許可/ブロックするといった運用ができます。事前にIssueごとに「このIssueで触って良いディレクトリ/モジュール」を記録し、PreToolUseフックでClaudeのファイル編集ツール呼び出し時にそのパスを検証する仕組みも考案できます。これにより、Claudeが勝手に他モジュールまで修正対象を広げないように強制できます。

* **Hookによる強制とフィードバック**: 以上のTDD違反やYAGNI逸脱の検出は、最終的には**HooksでClaudeにフィードバック**を与えて実現します。Claude Code Hooksは単なる通知に留まらず、**Claudeの行動を強制的に制御できる強力な手段**です。PreToolUseフックで問題のあるコマンドを**実行前にブロック**し、Claudeに「○○は禁止されています」とエラーを返せます。またPostToolUseフックやStopフックで**実行後に軌道修正**を指示できます。「作成されたコードがコーディング規約に違反しています」といった指摘を自動で行い、Claudeがそれを受けてスタイル修正する、といったことも可能です。Hookをコードレビュー的な役割で使い、**人間が指摘する前にAI自身に自己修正させる**のです。例えば、次のようなHookパターンが考えられます:

  * *TDD違反検出フック*: PreToolUseフック（Writeツールに対するGlobマッチ）で、新たにソースコードを書こうとした時に、直前にテストコードの変更がなかった場合ブロックする。「テストを書かずに実装を書こうとしています。まずテストを書いてください。」というエラーをClaudeに返し、テスト追加フェーズに強制的に戻します。
  * *未使用コード検出フック*: PostToolUseフック（テスト実行後）で未使用関数の検出ツールを実行。結果に未使用要素があればStopフックで対話終了をブロックし、「未使用のコードがあります。必要ないなら削除してください。」とClaudeに伝えます。Claudeは不要部分の削除コミットを行い、再度テストを実行するでしょう。
  * *ドメイン逸脱検出フック*: Stopフックで最終的な差分一覧をスクリプト解析し、Issue関連外のファイル変更があればClaudeに対し「変更範囲を絞るように」とメッセージを投げます。Claudeは余計な変更を巻き戻すか、新たなIssueに切り出す提案をするかもしれません。**HookによってClaudeの出力を調整することで、常にIssueごとのシングルタスクに集中させます**。
  * *複雑度チェックフック*: PostToolUseフックでコードのメトリクスを計算し、例えば「関数の長さが規定以上」「ネストが深すぎる」といった複雑度の閾値を超えた場合に警告を発します。Claudeに「関数Xが長すぎます。責務を分割してください。」と伝えることで、リファクタリングを追加で行わせます。SOLID原則（単一責任など）の遵守もここでチェックします。

以上のようなHooksの活用により、人手では困難なレベルで**開発プロセスの自動監査**が可能になります。従来、人間が「それは作りすぎでは？」「テスト書いて」と都度チェックしていたポイントを、Hooksが24時間見張ってくれるイメージです。HookはLLMと違い決め打ちのルールで動くため、プロジェクトで何が禁止・推奨かを明文化しさえすれば、それに反する行為を確実に検知・制御できます。この信頼性の高さが、AIエージェントによる開発でも品質と一貫性を維持する鍵となります。

### PR粒度の管理と自動化による複雑性抑制

AIエージェント開発では、一度に大きな変更をさせると不具合の原因特定やレビューが困難になり、複雑性が跳ね上がります。本フローでは**Pull Requestの粒度を小さく保つ**ことが重要な設計方針です。

* **1 Issue = 1 PR**: 先述の通り、Issueはできるだけ単一機能・単一不具合にフォーカスさせ、Claudeもそれに対応するコード変更だけを行います。PRはIssueに紐づき（コミットメッセージやPR本文にIssue番号を入れる）、複数Issueをまたぐ変更は原則禁止します。これにより、各PRのスコープが明確になり、Claudeの思考も単純化します。Hooksでも、PRのタイトルやコミットに複数のIssue参照がないかチェックし、もし見つかったらPR分割を促すことができます。

* **コミットの細分化**: Claudeに対しても「頻繁にコミットせよ」とガイドします。TDDの流れ上、**テスト追加→テスト失敗確認→実装→テスト成功**という1サイクルを1～2コミットに収めるのが理想です。Claude Codeは対話内で`git commit`を何度か行い中間結果を保存できます。コミット履歴が細かければ、後からの**コードレビューや問題発生時の原因追跡が容易**になります。加えて、小さいコミットであればClaude自身も変更の影響範囲を把握しやすく、誤りの修正が素早くなります。

* **PRサイズのモニタリング**: Hookを用いて、PRの差分行数や変更ファイル数を監視することも検討します。例えば、**差分行数が閾値（例: 500行）を超えた場合に警告**するStopフックを仕掛け、「変更が大きすぎます。一部を別PRに分割してください」とClaudeに伝えます。Claudeはそれを受け、変更セットをいくつかのPRに分けて再提出するよう誘導できます（ただし現在のClaude Code GitHub Actionsの仕組み上、一度のワークフローで複数PRを作るのは難しいかもしれません。その場合、一旦出力をユーザーが分割するか、もしくはClaudeに別Issueを自動生成させて（GitHub CLI経由でIssue作成→PR作成）対応するなど高度な施策が必要です）。いずれにせよ、\*\*「1PRで欲張らない」\*\*ことをClaudeに学習させ、仮にPRが大きくなりすぎたらそこで区切って次のPRに回すような習慣を付けさせます。

* **CI/CDとの統合**: すべてのPRには自動のCIチェック（テスト・Lint・型チェック・セキュリティスキャンなど）が付与されます。Claudeは事前にテストを通しているため基本的にCIもパスするはずですが、万一CIでエラーが出た場合はHook経由でClaudeに再フィードバックします。「CIでコードフォーマットに失敗しました」との結果をClaudeが受け取ったら、自動で`prettier`や`gofmt`を実行して再コミットする、といった流れです。また、AnthropicのClaude Codeには**PRレビューコメントに自動対応**する機能もあります。これを使えば、人間レビューで見つかった改善点もClaudeが即座に修正できます。CIとレビューによるチェック体制は、人間同士の開発と同様に重要です。AIエージェントと言えども誤りは起こり得るため、**最後の砦としてのCI/レビュー**は確保しつつ、その前段の段階（ローカルテスト段階）で可能な限りHookによる修正で問題を潰しておく、という二重の防御線を敷きます。

* **複雑性の早期可視化**: Claudeが書いたコードの複雑性（メンテしづらさ）は、放置すると蓄積します。これを抑えるには**早期に警告を上げる仕組み**が有効です。例えば、新規コードの中でネストが深い箇所を自動検知して「このロジックは複雑です。簡素化を検討してください。」とClaudeに伝えます。また、クラス設計が膨らみすぎたら「現在の設計はYAGNI違反の可能性があります。本当にそれだけの汎用性が必要ですか？」と問いかけるのも良いでしょう。Claudeは与えられたルールには従順なので、注意されれば素直に簡素化する傾向があります。プロジェクト初期からこの文化（シンプルに、必要なものだけ）を叩き込んでおくことで、後から大規模リファクタが必要になる事態を避けられます。

以上により、AIエージェント開発で懸念される\*\*「どんどんコードが膨れ上がって手に負えなくなる」\*\*というリスクを軽減します。TDDで必要な実装以外書かせず、YAGNIで将来の拡張を見越した余計なコードを書かせず、HookとCIで常に軌道修正することで、PR単位の完結した開発を繰り返せます。これを積み重ねることで、大規模になっても破綻しないクリーンなコードベースを維持できるでしょう。

## CLAUDE.md（プロジェクト憲法）の設計ベストプラクティス

Claude Codeの**CLAUDE.md**ファイルは、プロジェクト独自のルールやスタイルガイド、設計原則を記述する場所です。Claudeにとっては**最も重視すべき指令書**であり、これに書かれた内容はユーザーからのその場の指示よりも優先されるとされています。したがって、このCLAUDE.mdをいかに設計・運用するかが、Claudeエージェントを思い通りに動かす鍵になります。本フローに適したCLAUDE.mdのベストプラクティスを示します。

* **必要十分かつ簡潔に**: CLAUDE.mdはプロンプトの一種ですが、大量に書きすぎるとコンテクスト予算を圧迫し、パフォーマンス低下を招きます。Anthropicの公式ドキュメントも「CLAUDE.mdは簡潔かつ焦点を絞って書く」ことを推奨しています。そこで、本当にClaudeに守らせたい重要事項に絞り、箇条書きやセクションを分けて明確に記載します。TDDやYAGNIは最重要原則なので冒頭付近に太字で書き、具体的ルールも添えます。一方で細かなコーディングスタイル（インデント幅など）は既存のLint設定に任せ、CLAUDE.mdには**上位レベルの原則**（設計哲学やアーキテクチャ方針）を中心に据えます。例えば:

  * 「常にテスト駆動で開発する。実装前にテストを書き、テストが存在しない機能は作らないこと。」
  * 「YAGNIとKISSを徹底し、現在必要な機能以外は実装しない。コードは可能な限りシンプルに。」
  * 「SOLID原則やクリーンアーキテクチャに従う。特に単一責任と関心の分離を守り、1クラス/モジュールが担う責務を絞ること。」
  * 「コードスタイルはGoogleスタイルガイドに準拠。Lintエラーは残さないこと。」
  * 「既存のパターンを踏襲する。類似機能を実装する際は既存コードを調査し、一貫性のあるアプローチで書くこと。」
  * 「セキュリティ・性能に関するベストプラクティスを遵守（入力検証, SQLインジェクション防止, N+1クエリ防止など）。」
    このように、Claudeに**守ってほしいコーディング上のドント/ドゥ**を網羅的に書いておきます。CLAUDE.mdに書かれた指針は会話の最中ずっと保持され、Claudeの行動に影響を与え続けます。

* **メモリ拡張の慎重な取り扱い**: Claudeはデフォルトでは各セッションごとに新しい状態になります。継続的な記憶を持たせるにはCLAUDE.mdを更新していく必要がありますが、**むやみに追記しすぎない**ようにします。例えば、新しいルール（「○○関数は使わない方針に変更」など）を追加する場合、古いルールとの重複や矛盾がないか確認し、不要になった記述は削除します。CLAUDE.mdがどんどん長文化すると、Claudeが読み込むトークン数も増えコストと誤解の元になります。可能なら**モジュール化**して、章立てやコメントで区切りを入れることでClaudeがルールを誤って混同しないようにします。たとえば、「テスト駆動開発」「設計原則」「コーディング規約」「禁止事項」といった見出しで整理し、各セクションの情報量は抑えます。ClaudeLogの提言によると、CLAUDE.mdに**具体例**や**手順**を盛り込むのも有効です。Claudeは前文脈から推測して暴走するより、明示された手順に従う方が得意なので、例えば「新機能を実装する際のステップ1～5」や「バグ修正の基本手順（再現テストを書く→…）」などを記載します。これらは半ば**プロジェクトの流れを固定化したテンプレート**となり、Claudeがブレずに開発を進める助けになります。

* **既存コードや外部ドキュメントとの併用**: CLAUDE.mdには文章で書けることしか書けませんが、実際には**コードそのものが語るルール**もあります。Claude Codeはリポジトリ内のファイルを検索・参照できますので、あまりに長くなる規約説明はプロジェクトの`CONTRIBUTING.md`や建築図書的なドキュメントに譲り、Claudeには「○○.mdを読んで指針を理解すること」と促してもよいでしょう。Issueテンプレートでも繰り返し重要事項を記載することでClaudeに都度認識させることができます。CLAUDE.mdとそうしたドキュメント類の**役割分担**を決め、CLAUDE.mdは本当に厳守させるコア原則のみにフォーカスする運用が望ましいです。

* **Claude.mdの運用**: CLAUDE.mdはプロジェクト憲法ですから、変更時には開発者（人間）のレビューも必要です。下手に変更するとClaudeの振る舞いががらりと変わる可能性もあるため、CLAUDE.md自体を修正する際もPRを通し、AI提案＋人間承認で更新していくと良いでしょう。ClaudeにCLAUDE.mdのドラフトを書かせ、人間が推敲してマージ、という形です。そうすることで、Claude.mdの内容にも人間の知見とAIの提案力を両方反映できます。また、新たなトラブルが発生したらその防止策をClaude.mdに追記するのも有効です（例えば「今後このエッジケースを見逃さないようにテストを書くこと」と教訓を追加する）。

CLAUDE.mdの充実度合いはプロジェクト運営の成熟度を表します。Claude.mdにしっかり原則が書かれていれば、Claudeエージェントは**それを破ることはほとんどありません**。前述の通りClaude.mdの指示は絶対視されるため、逆に言えば書いていないことはClaudeには分からない可能性があります。ですから、「そんなことは常識だろう」と人間が思うことでも、AIには明文化して教える必要があります。チームでの当たり前（コーディング規約、設計思想、利用すべきユーティリティ関数など）はすべてClaude.mdに記載するつもりで整備してください。Claude.mdを中核に、HookやCIを周辺に配置した**多重ガード**がこのAI開発フローの肝となります。

## Claudeの行動提案におけるテンプレート設計

Claudeエージェントが一連の開発タスクを進める際、どのような手順・思考プロセスで動くかをあらかじめ設計し、その**テンプレート（ひな型）**を用意しておくと非常に効果的です。Claude Codeではカスタムの**スラッシュコマンド**を定義しておき、一連のプロンプトをテンプレート化することができます。これを活用して、「テストが先行し関心が分離された開発」を自然に行えるプロンプトフローを構築します。

### 開発フローのテンプレート化

例えば、新機能実装用に次のような**プロンプトテンプレート**を作成し、`.claude/commands/`ディレクトリに配置します:

```
/project:new-feature

You are implementing a new feature as described in GitHub Issue $ARGUMENTS.

Follow these steps:
1. **Analyze requirements** – Read the issue details and ask clarifying questions if needed. Do not write any code yet.
2. **Plan implementation** – Propose a simple design that fulfills the requirements. Ensure to apply KISS and YAGNI: only include what is necessary:contentReference[oaicite:84]{index=84}. Check that the design separates concerns (e.g., UI vs logic vs data) appropriately.
3. **Write tests first** – Create test cases covering the expected behavior and edge cases. Remember we are doing TDD:contentReference[oaicite:85]{index=85}, so write tests for even not-yet-implemented functionality without providing stub implementations.
4. **Run tests (expect failures)** – Execute the test suite and confirm new tests fail:contentReference[oaicite:86]{index=86}. Do NOT proceed until tests are failing for the right reasons.
5. **Implement code minimally** – Write just enough code to make the failing tests pass, and no more:contentReference[oaicite:87]{index=87}. Do not add any feature or config not demanded by tests.
6. **Run tests until green** – Re-run the test suite. If failures remain, iterate: fix the code and test again:contentReference[oaicite:88]{index=88}. Do not modify test assertions in this step.
7. **Refactor if needed** – If the passing code is messy or violates design principles, improve it while keeping tests green. Ensure single-responsibility and separation of concerns are maintained (e.g., no huge functions doing multiple things).
8. **Verify no unused code** – Double-check that no new function or class is left unused (if found, remove it or write a test for it).
9. **Update docs** – If this feature requires documentation or README updates, draft them.
10. **Commit and create PR** – Summarize changes in a commit message, mentioning the issue number. Ensure the PR description includes what was done and why.
```

上記は英語で記述しましたが、実際には日本語でIssueを書いているなら日本語でテンプレート化しても構いません。重要なのは、**Claudeに従ってほしい手順を明示的に段階ごとに示す**ことです。このようなテンプレートを用意して`/project:new-feature 123`のようにコマンドを呼べば、ClaudeはIssue 123を取得し、この手順に沿って作業を進めます。途中で質問があれば「ステップ1: 質問があります…」のように対話するでしょう。テンプレート内で`**...**`のように強調した箇所（例: “Write tests first”）はClaudeに対する明確な指示となり、遵守率が高まります。

同様に、**バグ修正用のテンプレート**も考えられます。例えば:

```
/project:fix-bug

You are fixing a bug described in Issue $ARGUMENTS.

Steps:
1. Reproduce the bug with a test – Write a test that fails due to the bug.
2. Run tests to confirm the bug is reproduced – The new test should fail at first.
3. Locate the cause – Identify where in the code the defect is happening (use the failing test stack trace or search the codebase).
4. Fix the bug – Modify the code to resolve the issue, without introducing side effects. Keep the fix as minimal as possible.
5. Run tests until they all pass – Ensure the previously failing test now passes and no other tests break.
6. Refactor if necessary – Clean up any code smells introduced by the fix (respecting our coding standards).
7. Commit and reference the issue – e.g., "Fix #123: <bug summary>".
```

このように、種類ごとにワークフローをテンプレ化しておけば、Claudeはそのレールに沿って動いてくれるため安心です。特にTDDプロセスでは、**「テスト→実装→テスト→リファクタ」のサイクル**をテンプレで示すことがポイントです。それに従うことで、Claudeがいきなり実装してしまう暴走を防ぎ、必ずテストを書いてからコードを書く順序を守らせます。

### 事前チェックリストとセルフレビュー

Claudeの提案行動において、各ステップの合間に**セルフチェック質問**を挟むデザインも有効です。例えば実装前のプラン提示後に:

* 「このプランはシンプルか？もっと簡単な方法はないか？」
* 「将来の拡張を入れ込んでいないか？（YAGNI違反がないか）」
* 「責務の分離は保たれているか？1つのモジュールで複数の役割を持っていないか？」（SOLIDのSRPチェック）

といった質問をClaude自身に投げかけさせます。Claudeは驚くほど真面目にこれらの質問に答え、自身のプランを見直すことがあります。テンプレートにセルフQAタイムを組み込むイメージです。これにより、人間が逐一指摘しなくても、Claudeが**事前に欠陥の芽を摘む**ようになります。

同様に、実装後・テスト合格後にも:

* 「新たな技術的負債を生んでいないか？リファクタすべき点はないか？」
* 「コードに重複や無駄はないか？（DRY原則の確認）」
* 「コードは読みやすいか？適切にコメントされ、命名も意図を表しているか？」

と自問させます。Claude.mdやテンプレ内で「完了前に上記をセルフチェックせよ」と書いておけば、Claudeはそれに従い最終調整を行うでしょう。特にAnthropicのガイドラインでは、Claudeがテストに受かって満足するタイミングで**別のサブエージェントに実装を評価させ、テストに過適合（オーバーフィッティング）していないか確認する**ことも提案されています。例えば「この実装はテストに通すためだけのハックになっていないか？汎用ケースでも正しく動くか？」といった観点です。これもテンプレに組み込めます（Claudeにもう一人Claudeを呼ばせて尋ねさせる、ということもClaude Codeなら可能です）。

### テンプレート設計の効果

きちんとテンプレート化されたプロンプトとチェックリストに沿って動くClaudeは、まるで熟練した開発者のように一貫した振る舞いを示します。特に本フローの目的である**TDD徹底**と**YAGNI遵守**について、テンプレートがガードレールとなり狂いを防ぎます。Claude自身も目の前のチェック項目を一つ一つクリアしていく感覚で進められるため、迷走しにくくなります。

人間側から見ると、各ステップでClaudeが生成したアウトプット（テストコード、設計プラン、実装コード、セルフレビューコメントなど）が逐次提供されるので、安心してモニタリングできます。仮に不適切な方向に行きかけても、ステップ単位で修正指示を入れやすい利点もあります。

**まとめると**、Claudeの行動提案テンプレートは本フローの円滑な実施に不可欠な要素です。CLAUDE.mdに網羅的なルールを書くのと相補的に、テンプレートで実行手順を具体化・順序立てすることで、Claudeエージェントがプロジェクトの開発プロセスに完璧に適合するようになります。今後プロジェクトが拡大しタスクが増えても、新しいテンプレートを追加して対応可能ですし、既存テンプレを改善して精度向上を図ることもできます。これにより、**AIエージェントによる開発の標準化と複製可能性**が高まり、複数並行エージェントを運用する際も各々が同じ品質基準と手続きを踏襲するようになります。

## おわりに: 複雑性を抑えたAI開発フローの展望

以上、Claude Codeエージェントを用いたTDD＋YAGNI指向の開発ワークフロー設計と、その運用ガイドラインについて詳述しました。本提案の要点を振り返ります。

* **Claude Codeの能力を引き出しつつ制御する基盤**として、「コンテクスト→ツール→権限制御→実行→フィードバック」のループを活用しました。CLAUDE.mdでプロジェクト憲法を定め、HooksでLLM任せにしない自動チェック機構を実装することで、AIの暴走を防ぎます。

* **テスト駆動開発（TDD）の組み込み**により、機能要件を過不足なく実装しバグを早期に捕捉するプロセスを実現しました。Claudeはテストを書いてからコードを書く流れを守るため、要求以上のコードを書く暇がなくなります。テストがフィードバックループとなり、AIの出力を正しく方向付けします。

* **YAGNI原則とその他の設計原則**をClaudeに遵守させることで、コードの過度な一般化・将来予測による複雑化を抑制しました。Claude.mdやテンプレートで「今必要なものだけ実装せよ」と繰り返し指示し、フックで未使用コードや不必要な部分を検出・削除することで、コードベースのシンプルさを維持します。

* **GitHub ActionsとHooksを組み合わせた自動化**によって、AIエージェントの動作をチームの開発フローに統合しました。IssueからPR作成・レビューまで一通りを自動化しつつ、各所に品質ゲート（テスト、Lint、Hooks）を配置したことで、人間による従来のコードレビュー文化とAI自動化とを両立させました。

* **CLAUDE.mdの管理**では、AIエージェントの強力な記憶装置としての特性を活かしつつ、情報過多による弊害を避ける方針を示しました。要点を簡潔にまとめ、Claudeに絶対守らせるルールだけを厳選して記述することで、指示の衝突や忘却を防ぎます。Claude.mdは生きた文書としてプロジェクトの成長に合わせアップデートし、AIも人間もそれを参照して開発を進めるという**共同ルールブック**となります。

* **Hooksとテンプレートの応用**によって、より高度な自動チェック・セルフリファクタリング・計画立案の質向上が期待できます。AI開発だからこそ、エラーの見逃しやヒューマンエラーを極限まで減らす仕組みを構築でき、結果として人間主体の開発より高い品質水準を維持することも不可能ではありません。Claude Code Hooksはまさに\*\*「プログラム可能な番人」\*\*として、開発フロー全体の品質を底上げします。

本提案フローを運用すれば、当初はセットアップやルール整備に手間がかかるものの、一度軌道に乗ればAIエージェントが粛々とタスクをこなし、人間は要件定義と最終判断に専念できるようになります。コードベースも必要以上に肥大化せずクリーンに保たれ、**複雑性の爆発を未然に防止**できます。むしろ厳格なルールの下でAIが働くことで、人間だけでは難しいレベルの厳密さでTDDや静的検証が実施される利点も生まれます。

最後に留意点として、どれほど優れたフローでも**完全に人間の監督無しに任せきりにしない**ことが大切です。Claudeエージェントは強力ですが万能ではなく、時には誤解や予期せぬ挙動もありえます。HooksやCLAUDE.mdでカバーしきれないケースも出てくるでしょう。その際は人間がルールを改善し、Claudeにフィードバックするサイクルを回してください。本フロー自体もアジャイルに進化させていく姿勢が重要です。

以上を踏まえ、Claude主導のAIエージェント開発における**複雑性を抑えるワークフロー**の設計と運用について提案しました。これにより、近い将来において人間とAIが協調しつつも、AIが主体的に高品質なソフトウェアを構築していく開発スタイルが十分実現可能であると考えられます。その第一歩として、本指針を参考にプロジェクト環境を整備していただければ幸いです。

**参考資料:** 本回答ではAnthropic社のClaude Code公式ドキュメント【1】【17】やベストプラクティス集【9】【10】、Claudeユーザーの経験談【15】、そしてソフトウェア原則に関する知見【14】を参照しました。適宜、それらから得られた知見を活用しつつ設計を組み立てています。詳細は各出典をご参照ください。